<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>薄荷柠檬的博客</title>
    <link>https://www.zelvan.net/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>一些平时学习笔记以及搜集到的好的文章</description>
    <pubDate>Fri, 09 Nov 2018 09:20:51 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Git教程(四)</title>
      <link>https://www.zelvan.net/Git-tutorial-4.html</link>
      <guid>https://www.zelvan.net/Git-tutorial-4.html</guid>
      <pubDate>Fri, 09 Nov 2018 09:12:46 GMT</pubDate>
      <description>
      
        &lt;!-- build time:Fri Nov 09 2018 21:13:27 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;标签管理&quot;&gt;&lt;a href=&quot;#标签管理&quot; class=&quot;headerlink&quot; title=&quot;标签管理&quot;&gt;&lt;/a&gt;标签管理&lt;/h3&gt;&lt;p&gt;发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。&lt;/p&gt;&lt;p&gt;Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。&lt;/p&gt;&lt;p&gt;Git有commit，为什么还要引入tag？&lt;/p&gt;&lt;p&gt;“请把上周一的那个版本打包发布，commit号是6a5819e…”&lt;/p&gt;&lt;p&gt;“一串乱七八糟的数字不好找！”&lt;/p&gt;&lt;p&gt;如果换一个办法：&lt;/p&gt;&lt;p&gt;“请把上周一的那个版本打包发布，版本号是v1.2”&lt;/p&gt;&lt;p&gt;“好的，按照tag v1.2查找commit就行！”&lt;/p&gt;&lt;p&gt;所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Nov 09 2018 21:13:27 GMT+0800 (GMT+08:00) --><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><p>Git有commit，为什么还要引入tag？</p><p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p><p>“一串乱七八糟的数字不好找！”</p><p>如果换一个办法：</p><p>“请把上周一的那个版本打包发布，版本号是v1.2”</p><p>“好的，按照tag v1.2查找commit就行！”</p><p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。<br><a id="more"></a></p><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p><pre><code>$ git branch* dev  master$ git checkout masterSwitched to branch &apos;master&apos;</code></pre><p>然后，敲命令git tag<name>就可以打一个新标签：</name></p><pre><code>$ git tag v1.0</code></pre><p>可以用命令git tag查看所有标签：</p><pre><code>$ git tagv1.0</code></pre><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的commit id，然后打上就可以了：</p><pre><code>$ git log --pretty=oneline --abbrev-commit12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 1014c805e2 fix bug 101e1e9c68 merge with no-fff52c633 add mergecf810e4 conflict fixed5dc6824 &amp; simple14096d0 AND simpleb17d20e branch testd46f35e remove test.txtb84166e add test.txt519219b git tracks changese43a48b understand how stage works1094adb append GPLe475afc add distributedeaadf4e wrote a readme file</code></pre><p>比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：</p><pre><code>$ git tag v0.9 f52c633</code></pre><p>再用命令git tag查看标签：</p><pre><code>$ git tagv0.9v1.0</code></pre><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show<tagname>查看标签信息：</tagname></p><pre><code>$ git show v0.9commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 21:56:54 2018 +0800    add mergediff --git a/readme.txt b/readme.txt...</code></pre><p>可以看到，v0.9确实打在add merge这次提交上。</p><p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：</p><pre><code>$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</code></pre><p>用命令git show<tagname>可以看到说明文字：</tagname></p><pre><code>$ git show v0.1tag v0.1Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 22:48:43 2018 +0800version 0.1 releasedcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 21:06:15 2018 +0800    append GPLdiff --git a/readme.txt b/readme.txt...</code></pre><p>注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p><h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><p>如果标签打错了，也可以删除：</p><pre><code>$ git tag -d v0.1Deleted tag &apos;v0.1&apos; (was f15b0dd)</code></pre><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令git push origin<tagname>：</tagname></p><pre><code>$ git push origin v1.0Total 0 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git * [new tag]         v1.0 -&gt; v1.0</code></pre><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><pre><code>$ git push origin --tagsTotal 0 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git * [new tag]         v0.9 -&gt; v0.9</code></pre><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><pre><code>$ git tag -d v0.9Deleted tag &apos;v0.9&apos; (was f52c633)</code></pre><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><pre><code>$ git push origin :refs/tags/v0.9To github.com:michaelliao/learngit.git - [deleted]         v0.9</code></pre><p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p><h3 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h3><p>在安装Git一节中，我们已经配置了user.name和user.email，实际上，Git还有很多可配置项。</p><p>比如，让Git显示颜色，会让命令输出看起来更醒目：</p><pre><code>$ git config --global color.ui true</code></pre><p>这样，Git会适当地显示不同的颜色，比如git status命令：<br><img src="/images/2018/git011.png" alt=""><br>文件名就会标上颜色。<br>我们在后面还会介绍如何更好地配置Git，以便让你的工作更高效。</p><h4 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h4><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示Untracked files …，有强迫症的童鞋心里肯定不爽。</p><p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p><p>不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p><p>忽略文件的原则是：</p><pre><code>忽略操作系统自动生成的文件，比如缩略图等；忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</code></pre><p>举个例子：</p><p>假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件：</p><pre><code># Windows:Thumbs.dbehthumbs.dbDesktop.ini</code></pre><p>然后，继续忽略Python编译产生的.pyc、.pyo、dist等文件或目录：</p><pre><code># Python:*.py[cod]*.so*.egg*.egg-infodistbuild</code></pre><p>加上你自己定义的文件，最终得到一个完整的.gitignore文件，内容如下：</p><pre><code># Windows:Thumbs.dbehthumbs.dbDesktop.ini# Python:*.py[cod]*.so*.egg*.egg-infodistbuild# My configurations:db.inideploy_key_rsa</code></pre><p>最后一步就是把.gitignore也提交到Git，就完成了！当然检验.gitignore的标准是git status命令是不是说working directory clean。</p><p>使用Windows的童鞋注意了，如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。</p><p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了：</p><pre><code>$ git add App.classThe following paths are ignored by one of your .gitignore files:App.classUse -f if you really want to add them.</code></pre><p>如果你确实想添加该文件，可以用-f强制添加到Git：</p><pre><code>$ git add -f App.class</code></pre><p>或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：</p><pre><code>$ git check-ignore -v App.class.gitignore:3:*.class    App.class</code></pre><p>Git会告诉我们，.gitignore的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p><h4 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h4><p>有没有经常敲错命令？比如git status？status这个单词真心不好记。</p><p>如果敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p><p>我们只需要敲一行命令，告诉Git，以后st就表示status：</p><pre><code>$ git config --global alias.st status</code></pre><p>好了，现在敲git st看看效果。</p><p>当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch：</p><pre><code>$ git config --global alias.co checkout$ git config --global alias.ci commit$ git config --global alias.br branch</code></pre><p>以后提交就可以简写成：</p><pre><code>$ git ci -m &quot;bala bala bala...&quot;</code></pre><p>–global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p><p>在撤销修改一节中，我们知道，命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：</p><pre><code>$ git config --global alias.unstage &apos;reset HEAD&apos;</code></pre><p>当你敲入命令：</p><pre><code>$ git unstage test.py</code></pre><p>实际上Git执行的是：</p><pre><code>$ git reset HEAD test.py</code></pre><p>配置一个git last，让其显示最后一次提交信息：</p><pre><code>$ git config --global alias.last &apos;log -1&apos;</code></pre><p>这样，用git last就能显示最近一次的提交：</p><pre><code>$ git lastcommit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2Merge: bd6ae48 291bea8Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Thu Aug 22 22:49:22 2013 +0800    merge &amp; fix hello.py</code></pre><p>甚至还有人丧心病狂地把lg配置成了：</p><pre><code>git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</code></pre><p>来看看git lg的效果：<br><img src="/images/2018/git012.png" alt=""></p><p>为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p><p>配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中：</p><pre><code>$ cat .git/config [core]    repositoryformatversion = 0    filemode = true    bare = false    logallrefupdates = true    ignorecase = true    precomposeunicode = true[remote &quot;origin&quot;]    url = git@github.com:michaelliao/learngit.git    fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;]    remote = origin    merge = refs/heads/master[alias]    last = log -1</code></pre><p>别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。</p><p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中：</p><pre><code>$ cat .gitconfig[alias]    co = checkout    ci = commit    br = branch    st = status[user]    name = Your Name    email = your@email.com</code></pre><p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p><h3 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h3><p>在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。</p><p>GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。</p><p>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。</p><p>假设你已经有sudo权限的用户账号，下面，正式开始安装。</p><h4 id="第一步，安装git："><a href="#第一步，安装git：" class="headerlink" title="第一步，安装git："></a>第一步，安装git：</h4><pre><code>$ sudo apt-get install git</code></pre><h4 id="第二步，创建一个git用户，用来运行git服务："><a href="#第二步，创建一个git用户，用来运行git服务：" class="headerlink" title="第二步，创建一个git用户，用来运行git服务："></a>第二步，创建一个git用户，用来运行git服务：</h4><pre><code>$ sudo adduser git</code></pre><h4 id="第三步，创建证书登录："><a href="#第三步，创建证书登录：" class="headerlink" title="第三步，创建证书登录："></a>第三步，创建证书登录：</h4><p>收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。</p><h4 id="第四步，初始化Git仓库："><a href="#第四步，初始化Git仓库：" class="headerlink" title="第四步，初始化Git仓库："></a>第四步，初始化Git仓库：</h4><p>先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：</p><pre><code>$ sudo git init --bare sample.git</code></pre><p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：</p><pre><code>$ sudo chown -R git:git sample.git</code></pre><h4 id="第五步，禁用shell登录："><a href="#第五步，禁用shell登录：" class="headerlink" title="第五步，禁用shell登录："></a>第五步，禁用shell登录：</h4><p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：</p><pre><code>git:x:1001:1001:,,,:/home/git:/bin/bash</code></pre><p>改为：</p><pre><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</code></pre><p>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p><h4 id="第六步，克隆远程仓库："><a href="#第六步，克隆远程仓库：" class="headerlink" title="第六步，克隆远程仓库："></a>第六步，克隆远程仓库：</h4><p>现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：</p><pre><code>$ git clone git@server:/srv/sample.gitCloning into &apos;sample&apos;...warning: You appear to have cloned an empty repository.</code></pre><p>剩下的推送就简单了。</p><h4 id="管理公钥"><a href="#管理公钥" class="headerlink" title="管理公钥"></a>管理公钥</h4><p>如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。</p><p>这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。</p><h4 id="管理权限"><a href="#管理权限" class="headerlink" title="管理权限"></a>管理权限</h4><p>有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。</p><p>这里我们也不介绍Gitolite了，不要把有限的生命浪费到权限斗争中。</p><p>本文转载自廖旭峰官网<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程</a></p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>https://www.zelvan.net/Git-tutorial-4.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git教程(三)</title>
      <link>https://www.zelvan.net/Git-tutorial-3.html</link>
      <guid>https://www.zelvan.net/Git-tutorial-3.html</guid>
      <pubDate>Fri, 09 Nov 2018 08:44:46 GMT</pubDate>
      <description>
      
        &lt;!-- build time:Fri Nov 09 2018 21:13:27 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;远程仓库&quot;&gt;&lt;a href=&quot;#远程仓库&quot; class=&quot;headerlink&quot; title=&quot;远程仓库&quot;&gt;&lt;/a&gt;远程仓库&lt;/h3&gt;&lt;p&gt;到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。&lt;/p&gt;&lt;p&gt;可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。&lt;/p&gt;&lt;p&gt;没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Nov 09 2018 21:13:27 GMT+0800 (GMT+08:00) --><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。</p><p>可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。</p><p>没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。<br><a id="more"></a><br>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p><p>你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？</p><p>其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。</p><p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p><p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p><p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><pre><code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></pre><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p><p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：<br><img src="/images/2018/git008.png" alt=""><br>点“Add Key”，你就应该看到已经添加的Key：<br><img src="/images/2018/git009.png" alt=""></p><p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p><p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p><p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p><p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p><p>确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。</p><h4 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h4><p>在GitHub上的创建一个新的仓库learngit，创建好后GitHub告诉我们这个learngit仓库还是空的，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：</p><pre><code>$ git remote add origin git@github.com:michaelliao/learngit.git</code></pre><p>请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p><p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</p><p>下一步，就可以把本地库的所有内容推送到远程库上：</p><pre><code>$ git push -u origin masterCounting objects: 20, done.Delta compression using up to 4 threads.Compressing objects: 100% (15/15), done.Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.Total 20 (delta 5), reused 0 (delta 0)remote: Resolving deltas: 100% (5/5), done.To github.com:michaelliao/learngit.git * [new branch]      master -&gt; masterBranch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;.</code></pre><p>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。</p><p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。<br>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：<br><img src="/images/2018/git010.png" alt=""><br>从现在起，只要本地作了提交，就可以通过命令：</p><pre><code>$ git push origin master</code></pre><p>把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！<br>SSH警告</p><p>当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：</p><pre><code>The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)?</code></pre><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。</p><p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><pre><code>Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts.</code></pre><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><p>如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。</p><h4 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h4><p>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。<br>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p><p>首先，登陆GitHub，创建一个新的仓库，名字叫gitskills：</p><p>我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件<br>现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库：</p><pre><code>$ git clone git@github.com:michaelliao/gitskills.gitCloning into &apos;gitskills&apos;...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3Receiving objects: 100% (3/3), done.</code></pre><p>注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了：</p><pre><code>$ cd gitskills$ lsREADME.md</code></pre><p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p><p>你也许还注意到，GitHub给出的地址不止一个，还可以用<a href="https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。" target="_blank" rel="noopener">https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</a></p><p>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p><p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p><p><img src="/images/2018/git013.png" alt=""></p><p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p><p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p><p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p><p>但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p><h4 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h4><p>首先，我们创建dev分支，然后切换到dev分支：</p><pre><code>$ git checkout -b devSwitched to a new branch &apos;dev&apos;</code></pre><p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</p><pre><code>$ git branch dev$ git checkout devSwitched to branch &apos;dev&apos;</code></pre><p>然后，用git branch命令查看当前分支：</p><pre><code>$ git branch* dev  master</code></pre><p>git branch命令会列出所有分支，当前分支前面会标一个*号。</p><p>然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：</p><pre><code>Creating a new branch is quick.</code></pre><p>然后提交：</p><pre><code>$ git add readme.txt $ git commit -m &quot;branch test&quot;[dev b17d20e] branch test 1 file changed, 1 insertion(+)</code></pre><p>现在，dev分支的工作完成，我们就可以切换回master分支：</p><pre><code>$ git checkout masterSwitched to branch &apos;master&apos;</code></pre><p>切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：</p><p><img src="/images/2018/git014.png" alt=""></p><p>现在，我们把dev分支的工作成果合并到master分支上：</p><pre><code>$ git merge devUpdating d46f35e..b17d20eFast-forward readme.txt | 1 + 1 file changed, 1 insertion(+)</code></pre><p>git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</p><p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p><p>当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。</p><p>合并完成后，就可以放心地删除dev分支了：</p><pre><code>$ git branch -d devDeleted branch dev (was b17d20e).</code></pre><p>删除后，查看branch，就只剩下master分支了：</p><pre><code>$ git branch* master</code></pre><p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</p><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p><p>准备新的feature1分支，继续我们的新分支开发：</p><pre><code>$ git checkout -b feature1Switched to a new branch &apos;feature1&apos;</code></pre><p>修改readme.txt最后一行，改为：</p><pre><code>Creating a new branch is quick AND simple.</code></pre><p>在feature1分支上提交：</p><pre><code>$ git add readme.txt$ git commit -m &quot;AND simple&quot;[feature1 14096d0] AND simple 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre><p>切换到master分支：</p><pre><code>$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 1 commit.  (use &quot;git push&quot; to publish your local commits)</code></pre><p>Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。</p><p>在master分支上把readme.txt文件的最后一行改为：</p><pre><code>Creating a new branch is quick &amp; simple.</code></pre><p>提交：</p><pre><code>$ git add readme.txt </code></pre><p>$ git commit -m “&amp; simple”<br>[master 5dc6824] &amp; simple<br>1 file changed, 1 insertion(+), 1 deletion(-)</p><p>现在，master分支和feature1分支各自都分别有新的提交，变成了这样：</p><p><img src="/images/2018/git015.png" alt=""></p><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p><pre><code>$ git merge feature1Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result.</code></pre><p>果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件：</p><pre><code>$ git statusOn branch masterYour branch is ahead of &apos;origin/master&apos; by 2 commits.  (use &quot;git push&quot; to publish your local commits)You have unmerged paths.  (fix conflicts and run &quot;git commit&quot;)  (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths:  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)    both modified:   readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>我们可以直接查看readme.txt的内容：</p><pre><code>Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</code></pre><p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：</p><pre><code>Creating a new branch is quick and simple.</code></pre><p>再提交：</p><pre><code>$ git add readme.txt $ git commit -m &quot;conflict fixed&quot;[master cf810e4] conflict fixed</code></pre><p>现在，master分支和feature1分支变成了下图所示：</p><p><img src="/images/2018/git015.png" alt=""></p><p>用带参数的git log也可以看到分支的合并情况：</p><pre><code>$ git log --graph --pretty=oneline --abbrev-commit*   cf810e4 (HEAD -&gt; master) conflict fixed|\  | * 14096d0 (feature1) AND simple* | 5dc6824 &amp; simple|/  * b17d20e branch test* d46f35e (origin/master) remove test.txt* b84166e add test.txt* 519219b git tracks changes* e43a48b understand how stage works* 1094adb append GPL* e475afc add distributed* eaadf4e wrote a readme file</code></pre><p>最后，删除feature1分支：</p><pre><code>$ git branch -d feature1Deleted branch feature1 (was 14096d0).</code></pre><p>工作完成。</p><p>本文转载自廖旭峰官网<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程</a></p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>https://www.zelvan.net/Git-tutorial-3.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git教程(二)</title>
      <link>https://www.zelvan.net/Git-tutorial-2.html</link>
      <guid>https://www.zelvan.net/Git-tutorial-2.html</guid>
      <pubDate>Fri, 09 Nov 2018 07:44:46 GMT</pubDate>
      <description>
      
        &lt;!-- build time:Fri Nov 09 2018 21:13:27 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;版本回退&quot;&gt;&lt;a href=&quot;#版本回退&quot; class=&quot;headerlink&quot; title=&quot;版本回退&quot;&gt;&lt;/a&gt;版本回退&lt;/h3&gt;&lt;p&gt;现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Git is a distributed version control system.
Git is free software distributed under the GPL.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后尝试提交：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ git add readme.txt
$ git commit -m &amp;quot;append GPL&amp;quot;
[master 1094adb] append GPL
 1 file changed, 1 insertion(+), 1 deletion(-)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Nov 09 2018 21:13:27 GMT+0800 (GMT+08:00) --><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：</p><pre><code>Git is a distributed version control system.Git is free software distributed under the GPL.</code></pre><p>然后尝试提交：</p><pre><code>$ git add readme.txt$ git commit -m &quot;append GPL&quot;[master 1094adb] append GPL 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre><p>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。<br><a id="more"></a><br>现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：</p><p>版本1：wrote a readme file</p><pre><code>Git is a version control system.Git is free software.</code></pre><p>版本2：add distributed</p><pre><code>Git is a distributed version control system.Git is free software.</code></pre><p>版本3：append GPL</p><pre><code>Git is a distributed version control system.Git is free software distributed under the GPL.</code></pre><p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：</p><pre><code>$ git logcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 21:06:15 2018 +0800    append GPLcommit e475afc93c209a690c39c13a46716e8fa000c366Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 21:03:36 2018 +0800    add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 20:59:18 2018 +0800    wrote a readme file</code></pre><p>git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。</p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数：</p><pre><code>$ git log --pretty=oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</code></pre><p>需要友情提示的是，你看到的一大串类似1094adb…的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：<br><img src="/images/2018/git005.jpg" alt=""><br>好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是add distributed的那个版本，怎么做呢？</p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p><p>现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：</p><pre><code>$ git reset --hard HEAD^HEAD is now at e475afc add distributed</code></pre><p>–hard参数有啥意义？这个后面再讲，现在你先放心使用。</p><p>看看readme.txt的内容是不是版本add distributed：</p><pre><code>$ cat readme.txtGit is a distributed version control system.Git is free software.</code></pre><p>果然被还原了。</p><p>还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态：</p><pre><code>$ git logcommit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 21:03:36 2018 +0800    add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 20:59:18 2018 +0800    wrote a readme file</code></pre><p>最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p><p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb…，于是就可以指定回到未来的某个版本：</p><pre><code>$ git reset --hard 1094aHEAD is now at 83b0afe append GPL</code></pre><p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p><p>再小心翼翼地看看readme.txt的内容：</p><pre><code>$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.</code></pre><p>果然，我胡汉三又回来了。</p><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL：<br><img src="/images/2018/git006.jpg" alt=""><br>改为指向add distributed：<br><img src="/images/2018/git007.jpg" alt=""><br>然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p><p>在Git中，总是有后悔药可以吃的。当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：</p><pre><code>$ git refloge475afc HEAD@{1}: reset: moving to HEAD^1094adb (HEAD -&gt; master) HEAD@{2}: commit: append GPLe475afc HEAD@{3}: commit: add distributedeaadf4e HEAD@{4}: commit (initial): wrote a readme file</code></pre><p>终于舒了口气，从输出可知，append GPL的commit id是1094adb，现在，你又可以乘坐时光机回到未来了。</p><h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p><p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：</p><pre><code>$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes.</code></pre><p>然后，添加：</p><pre><code>$ git add readme.txt$ git status# On branch master# Changes to be committed:#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)##       modified:   readme.txt#</code></pre><p>然后，再修改readme.txt：</p><pre><code>$ cat readme.txt Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.</code></pre><p>提交：</p><pre><code>$ git commit -m &quot;git tracks changes&quot;[master 519219b] git tracks changes 1 file changed, 1 insertion(+)</code></pre><p>提交后，再看看状态：</p><pre><code>$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>咦，怎么第二次的修改没有被提交？</p><p>别激动，我们回顾一下操作过程：</p><p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit</p><p>你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>提交后，用git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别：</p><pre><code>$ git diff HEAD -- readme.txt diff --git a/readme.txt b/readme.txtindex 76d770f..a9c5755 100644--- a/readme.txt+++ b/readme.txt@@ -1,4 +1,4 @@ Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage.-Git tracks changes.+Git tracks changes of files.</code></pre><p>可见，第二次修改确实没有被提交。<br>那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：</p><p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p><p>好，现在，把第二次修改提交了，然后开始小结。</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行：</p><pre><code>$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.</code></pre><p>在你准备提交前，一杯咖啡起了作用，你猛然发现了stupid boss可能会让你丢掉这个月的奖金！</p><p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下：</p><pre><code>$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>你可以发现，Git会告诉你，git checkout – file可以丢弃工作区的修改：</p><pre><code>$ git checkout -- readme.txt</code></pre><p>命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p><p>现在，看看readme.txt的文件内容：</p><pre><code>$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.</code></pre><p>文件内容果然复原了。</p><p>git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令</p><p>现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了：</p><pre><code>$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.$ git add readme.txt</code></pre><p>庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交：</p><pre><code>$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    modified:   readme.txt</code></pre><p>Git同样告诉我们，用命令git reset HEAD<file>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</file></p><pre><code>$ git reset HEAD readme.txtUnstaged changes after reset:M    readme.txt</code></pre><p>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</p><p>再用git status查看一下，现在暂存区是干净的，工作区有修改：</p><pre><code>$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   readme.txt</code></pre><p>还记得如何丢弃工作区的修改吗？</p><pre><code>$ git checkout -- readme.txt$ git statusOn branch masternothing to commit, working tree clean</code></pre><p>整个世界终于清静了！</p><p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把stupid boss提交推送到远程版本库，你就真的惨了……</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：</p><pre><code>$ git add test.txt$ git commit -m &quot;add test.txt&quot;[master b84166e] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt</code></pre><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：</p><pre><code>$ rm test.txt</code></pre><p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：</p><pre><code>$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    deleted:    test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：</p><pre><code>$ git rm test.txtrm &apos;test.txt&apos;$ git commit -m &quot;remove test.txt&quot;[master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt</code></pre><p>现在，文件就从版本库中被删除了。</p><p>小提示：先手动删除文件，然后使用git rm<file>和git add<file>效果是一样的。</file></file></p><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><pre><code>$ git checkout -- test.txt</code></pre><p>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><p>本文转载自廖旭峰官网<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程</a></p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>https://www.zelvan.net/Git-tutorial-2.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git教程(一)</title>
      <link>https://www.zelvan.net/Git-tutorial-1.html</link>
      <guid>https://www.zelvan.net/Git-tutorial-1.html</guid>
      <pubDate>Thu, 08 Nov 2018 07:44:46 GMT</pubDate>
      <description>
      
        &lt;!-- build time:Fri Nov 09 2018 21:13:27 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;img src=&quot;/images/2018/git001.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;h3 id=&quot;安装Git&quot;&gt;&lt;a href=&quot;#安装Git&quot; class=&quot;headerlink&quot; title=&quot;安装Git&quot;&gt;&lt;/a&gt;安装Git&lt;/h3&gt;&lt;p&gt;最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。&lt;/p&gt;&lt;p&gt;要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字：&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Nov 09 2018 21:13:27 GMT+0800 (GMT+08:00) --><p><img src="/images/2018/git001.jpg" alt=""></p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p><p>要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字：<br><a id="more"></a></p><h4 id="在Linux上安装Git"><a href="#在Linux上安装Git" class="headerlink" title="在Linux上安装Git"></a>在Linux上安装Git</h4><p>首先，你可以试着输入git，看看系统有没有安装Git：</p><pre><code>$ gitThe program &apos;git&apos; is currently not installed. You can install it by typing:sudo apt-get install git</code></pre><p>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p><p>如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。</p><p>老一点的Debian或Ubuntu Linux，要把命令改为sudo apt-get install git-core，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。</p><p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。</p><h4 id="在Mac-OS-X上安装Git"><a href="#在Mac-OS-X上安装Git" class="headerlink" title="在Mac OS X上安装Git"></a>在Mac OS X上安装Git</h4><p>如果你正在使用Mac做开发，有两种安装Git的方法。</p><p>一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/。" target="_blank" rel="noopener">http://brew.sh/。</a></p><p>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。<br><img src="/images/2018/git002.jpg" alt=""><br>Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！</p><h4 id="在Windows上安装Git"><a href="#在Windows上安装Git" class="headerlink" title="在Windows上安装Git"></a>在Windows上安装Git</h4><p>在Windows上使用Git，可以从Git官网直接下载安装程序，（网速慢的同学请移步国内镜像），然后按默认选项安装即可。</p><p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！<br><img src="/images/2018/git003.jpg" alt=""></p><h4 id="安装完成后配置"><a href="#安装完成后配置" class="headerlink" title="安装完成后配置"></a>安装完成后配置</h4><p>安装完成后，还需要最后一步设置，在命令行输入：</p><pre><code>$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;</code></pre><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p><p>注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p><pre><code>$ mkdir learngit$ cd learngit$ pwd/Users/michael/learngit</code></pre><p>pwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。</p><p>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</p><p>第二步，通过git init命令把这个目录变成Git可以管理的仓库：</p><pre><code>$ git initInitialized empty Git repository in /Users/michael/learngit/.git/</code></pre><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><p>如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。<br>也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。</p><h3 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h3><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p><p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p><p>使用Windows的童鞋要特别注意：</p><p>千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：<br><img src="/images/2018/git004.jpg" alt=""><br>言归正传，现在我们编写一个readme.txt文件，内容如下：</p><pre><code>Git is a version control system.Git is free software.</code></pre><p>一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p><p>和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p><p>第一步，用命令git add告诉Git，把文件添加到仓库：</p><pre><code>$ git add readme.txt</code></pre><p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p><p>第二步，用命令git commit告诉Git，把文件提交到仓库：</p><pre><code>$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt</code></pre><p>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>嫌麻烦不想输入-m “xxx”行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p><p>git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。<br>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p><pre><code>$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot;</code></pre><p>本文转载自廖旭峰官网<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程</a></p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>https://www.zelvan.net/Git-tutorial-1.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Vim编辑器</title>
      <link>https://www.zelvan.net/Vim-editor.html</link>
      <guid>https://www.zelvan.net/Vim-editor.html</guid>
      <pubDate>Tue, 06 Nov 2018 11:44:46 GMT</pubDate>
      <description>
      
        &lt;!-- build time:Fri Nov 09 2018 21:13:27 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;vim主要模式介绍，vim命令模式。&quot;&gt;&lt;a href=&quot;#vim主要模式介绍，vim命令模式。&quot; class=&quot;headerlink&quot; title=&quot;vim主要模式介绍，vim命令模式。&quot;&gt;&lt;/a&gt;vim主要模式介绍，vim命令模式。&lt;/h3&gt;&lt;p&gt;确保系统已经安装了VIM工具&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@panda ~]# rpm -qf `which vim`
[root@panda ~]# rpm -qf `which vi`
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;扩展：&lt;br&gt;问：vi和vim是同一个软件包安装的吗?&lt;br&gt;答：NO，vim是vi的增加版，最明显的区别就是vim可以语法加亮，它完全兼容vi&lt;/p&gt;&lt;h4 id=&quot;1-vim编辑器模式&quot;&gt;&lt;a href=&quot;#1-vim编辑器模式&quot; class=&quot;headerlink&quot; title=&quot;1.  vim编辑器模式&quot;&gt;&lt;/a&gt;1. vim编辑器模式&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/2018/vim001.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Nov 09 2018 21:13:27 GMT+0800 (GMT+08:00) --><h3 id="vim主要模式介绍，vim命令模式。"><a href="#vim主要模式介绍，vim命令模式。" class="headerlink" title="vim主要模式介绍，vim命令模式。"></a>vim主要模式介绍，vim命令模式。</h3><p>确保系统已经安装了VIM工具</p><pre><code>[root@panda ~]# rpm -qf `which vim`[root@panda ~]# rpm -qf `which vi`</code></pre><p>扩展：<br>问：vi和vim是同一个软件包安装的吗?<br>答：NO，vim是vi的增加版，最明显的区别就是vim可以语法加亮，它完全兼容vi</p><h4 id="1-vim编辑器模式"><a href="#1-vim编辑器模式" class="headerlink" title="1.  vim编辑器模式"></a>1. vim编辑器模式</h4><p><img src="/images/2018/vim001.png" alt=""><br><a id="more"></a><br>首次进入文件 —- 命令模式<br>出现 “Insert” —- 编辑模式<br>输入: —- 命令行模式<br>A：从编辑模式到命令行模式怎样切换?<br>编辑模式-&gt;esc-&gt;命令模式-&gt;: -&gt;命令行模式<br>B：字符操作(怎样进入编辑模式?)<br>进入编辑模式 a i o A I O<br>说明：<br>i 当前字符之前插入 (光标前)<br>I 行首插入 (行首)<br>a 当前字符之后插入 (光标后)<br>A 行尾插入(行尾)<br>o下一行插入 (另起一行)<br>O上一行插入(上一行插入)<br>x 向后删除一个字符 等同于delete<br>X 向前删除一个字符<br>u 撤销一步 每按一次就撤销一次<br>r 替换</p><h4 id="2-在命令模式下做的操作："><a href="#2-在命令模式下做的操作：" class="headerlink" title="2.  在命令模式下做的操作："></a>2. 在命令模式下做的操作：</h4><h5 id="光标定位"><a href="#光标定位" class="headerlink" title="光标定位"></a>光标定位</h5><p>hjkl 左下上右<br>0 和 home键表示切换到行首， $和end键表示切换到行尾<br>gg 快速定位到文档的首行 , G定位到未行<br>3gg 或者 3G 快速定位到第3行<br>/string(字符串) —–找到或定位你要找的单词或内容，如果相符内容比较多，我们可以通过N、n来进行向上向下查找，并且vi会对查找到的内容进行高亮显示，取消用 :noh<br>/^d —-^意思表示以什么开头 ，，查找以字母d开头的内容<br>/t$ —–$意思表示以什么结尾，，查找以字母t结尾的内容<br>vim + a.txt 打开文件后，光标会自动位于文件的最后一行</p><h5 id="如何对文本进行编辑"><a href="#如何对文本进行编辑" class="headerlink" title="如何对文本进行编辑"></a>如何对文本进行编辑</h5><p>删除、复制、粘贴、撤销<br>y 复制（以字符为单位） :表示对单个字符进行复制，如果要复制整行，用yy（以行为单位）<br>复制N行： Nyy ，比如： 2yy ，表示复制2行<br>dd（删除，以行为单位，删除当前光标所在行）<br>删除N行： Ndd ，比如： 2dd ，表示删除2行<br>p ： P粘贴<br>剪切： dd<br>x 删除光标所在位置的字符<br>D 从光标处删除到行尾<br>u 撤销操作<br>ctrl+r 还原撤销过的操作，将做过的撤销操作再还原回去，也就是说撤销前是什么样，再还原成什么样<br>r 替换，或者说用来修改一个字符</p><h5 id="总结：vim如何进入其它模式"><a href="#总结：vim如何进入其它模式" class="headerlink" title="总结：vim如何进入其它模式"></a>总结：vim如何进入其它模式</h5><p>a A o O i I 都是可以进行插入，编辑模式<br>： 进入命令行模式<br>v 进入可视模式<br>ctrl+v 进入可视块模式<br>V 进入可视行模式<br>R 擦除、改写，进入替换模式<br>你进入以上模式后，想要退出 ，按esc<br>扩展：插入模式中的操作<br>ctrl+p可以进行补全操作,所需要的内容必须是在当前打开的文件内存在的，它只针对当前文件</p><h4 id="3-V模式（列）"><a href="#3-V模式（列）" class="headerlink" title="3.  V模式（列）"></a>3. V模式（列）</h4><p>进入v模式 移动光标选择区域、<br>编程的时候需要进行多行注释：<br>1)、ctrl+v 进入列编辑模式<br>2)、向下或向上移动光标，把需要注释、编辑的行的开头选中起来<br>4)、然后按大写的I<br>5)、再插入注释符或者你需要插入的符号,比如”#”<br>6)、再按Esc,就会全部注释或添加了</p><p>删除：再按ctrl+v 进入列编辑模式；向下或向上移动光标 ；选中注释部分,然后按d, 就会删除注释符号。</p><h4 id="4-命令行模式操作"><a href="#4-命令行模式操作" class="headerlink" title="4.  命令行模式操作"></a>4. 命令行模式操作</h4><p>:w 保存 save<br>:w! 强制保存<br>:q 没有进行任何修改，退出 quit<br>:q! 修改了，不保存，强制退出<br>:wq 保存并退出<br>:wq! 强制保存并退出<br>:x 保存退出<br>例: wq! 强制保存并退出</p><pre><code>[root@xuegod63 ~]# ll /etc/shadow----------. 1 root root 1179 9月  19 12:57 /etc/shadow[root@xuegod63 ~]# vim /etc/shadow</code></pre><h5 id="调用外部文件或命令"><a href="#调用外部文件或命令" class="headerlink" title="调用外部文件或命令"></a>调用外部文件或命令</h5><p>假设：我想要写入我的网卡MAC地址,,我要查看一下,当前在vim编辑文档，照着写。这样好麻烦。<br>在命令行模式下操作：<br>:!ifconfig 调用系统命令<br>!+命令<br>读取其他文件。（把其他文件中的内容追加到当前文档中）<br>:r /etc/hosts</p><h5 id="文本替换"><a href="#文本替换" class="headerlink" title="文本替换"></a>文本替换</h5><p>格式 : 范围（其中%所有内容） s分隔符 旧的内容 分隔符 新的内容 （分隔符可以自定义）<br>默认是每一行的第一个符合要求的词 (/g全部)</p><pre><code>:1,3 s/bin/xuegod    替换第1到3行中出现的第一个bin进行替换为xuegod:1,3 s/bin/xuegod/g  替换第1到3行中查找到所有的bin进行替换为xuegod:3 s/xue/aaaaa     #只把第3行中内容替换了:% s/do/xuegod/g      将文本中所有的do替换成xuegod:% s/do/xuegod/gi    将文本中所有的do替换成xuegod, 并且忽略do的大小写:% s@a@b@g       将文本中所有的a替换成b</code></pre><h4 id="5-自定义vim使用环境"><a href="#5-自定义vim使用环境" class="headerlink" title="5. 自定义vim使用环境"></a>5. 自定义vim使用环境</h4><h5 id="临时设置"><a href="#临时设置" class="headerlink" title="临时设置"></a>临时设置</h5><p>:set nu 设置行号<br>:set nonu 取消设置行号<br>:noh 取消高亮显示</p><h5 id="永久设置环境"><a href="#永久设置环境" class="headerlink" title="永久设置环境"></a>永久设置环境</h5><p>vim /etc/vimrc 设置后会影响到系统所有的用户<br>~/.vimrc #在用户的家目录下，创建一个.vimrc。这样只影响到某一个用户，没有自己建一个<br>例：</p><pre><code>[root@xuegod63 ~]# cat  /root/.vimrc  set nu[root@xuegod63 ~]# vim  /root/.vimrc</code></pre><p><img src="/images/2018/vim002.png" alt=""></p><h4 id="6-vim-其他常用命令"><a href="#6-vim-其他常用命令" class="headerlink" title="6. vim 其他常用命令"></a>6. vim 其他常用命令</h4><h5 id="vim打开多个文件"><a href="#vim打开多个文件" class="headerlink" title="vim打开多个文件"></a>vim打开多个文件</h5><p>方法1：以上下形势，打开两个文档</p><pre><code>[root@xuegod63 ~]# vim -o /etc/passwd /etc/hosts</code></pre><p><img src="/images/2018/vim003.png" alt=""></p><p>方法2：以左右方式打开两个文档</p><pre><code>[root@xuegod63 ~]# vim -O /etc/passwd /etc/hosts</code></pre><p>注：ctrl+ww 在两文档之间进行切换编辑。大写O左右分屏，小写的o上下分屏</p><h5 id="比较两个文件内容"><a href="#比较两个文件内容" class="headerlink" title="比较两个文件内容"></a>比较两个文件内容</h5><pre><code>[root@xuegod63 ~]# cp /etc/passwd mima.txt[root@xuegod63 ~]# echo aaa &gt;&gt; mima.txt [root@xuegod63 ~]# diff /etc/passwd mima.txt 40a41&gt; aaa[root@xuegod63 ~]# vimdiff /etc/passwd mima.txt</code></pre><h4 id="7-实战1：在windows中编辑好的汉字文本文档，上传到Linux下打开乱码。"><a href="#7-实战1：在windows中编辑好的汉字文本文档，上传到Linux下打开乱码。" class="headerlink" title="7.  实战1：在windows中编辑好的汉字文本文档，上传到Linux下打开乱码。"></a>7. 实战1：在windows中编辑好的汉字文本文档，上传到Linux下打开乱码。</h4><p>实验环境：centos7.4 现在系统默认使用的语言是汉语。（系统中必须安装好中文包）。<br>将同目录下“a此文件在windows下打开正常-到linux下vim打开是乱码.txt”上传到Linux服务器上。使用ssh远程连接到Linux上，使用vim打开显示乱码。<br>原因：编码的问题<br>通过iconv命令转码 没有使用过：1<br>参数：<br>-f, –from-code=名称 原始文本编码<br>-t, –to-code=输出编码<br>-o, –output=FILE 输出文件名</p><pre><code>[root@xuegod63 ~]# mkdir test  #创建一个测试目录[root@xuegod63 ~]# cd test/</code></pre><p>将测试的文件上传到Linux服务器上：<br><img src="/images/2018/vim004.png" alt=""></p><pre><code>[root@xuegod63 ~]# iconv -f gb2312  -t utf8 a此文件在windows下打开正常-到linux下vim打开是乱码.txt  -o aa.txt[root@xuegod63 ~]# cat aa.txt #!/bin/bashecho &quot;学神IT&quot;信息：-l, --list 列举所有已知的字符集</code></pre><h4 id="8-实战2：解决将公司Linux服务器上脚本导到windows上打开串行的问题"><a href="#8-实战2：解决将公司Linux服务器上脚本导到windows上打开串行的问题" class="headerlink" title="8.  实战2：解决将公司Linux服务器上脚本导到windows上打开串行的问题"></a>8. 实战2：解决将公司Linux服务器上脚本导到windows上打开串行的问题</h4><p>原因：因为windows和linux处理回车方法不同。<br>上传” b在Linux编辑的文档到windows下没有换行.sh” 到Linux上，打开后正常显示</p><pre><code>[root@localhost test]# sz b在Linux编辑的文档到windows下没有换行.sh   #发送到本地</code></pre><p>在window 上打开显示：<br><img src="/images/2018/vim005.png" alt=""></p><p>解决方法：</p><pre><code>[root@xuegod63 ~]# rpm -ivh /mnt/Packages/dos2unix-6.0.3-7.el7.x86_64.rpm注： 在centos7上，unix2dos这个命令已经被集成到dos2unix-6.0.3-7.el7.x86_64.rpm包中。在centos6下需要安装unix2dos.xxx.rpm。[root@localhost test]# unix2dos b在Linux编辑的文档到windows下没有换行.sh[root@localhost test]# sz b在Linux编辑的文档到windows下没有换行.sh   #发送到windows本地  显示正常。</code></pre><p><img src="/images/2018/vim006.png" alt=""><br>注：dos2unix 这个命令是把windows下的回车转成linux类型。</p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>https://www.zelvan.net/Vim-editor.html#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
