<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git教程(四)]]></title>
    <url>%2FGit-tutorial-4.html</url>
    <content type="text"><![CDATA[标签管理发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。Git有commit，为什么还要引入tag？“请把上周一的那个版本打包发布，commit号是6a5819e…”“一串乱七八糟的数字不好找！”如果换一个办法：“请把上周一的那个版本打包发布，版本号是v1.2”“好的，按照tag v1.2查找commit就行！”所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。创建标签在Git中打标签非常简单，首先，切换到需要打标签的分支上：$ git branch * dev master $ git checkout master Switched to branch &apos;master&apos; 然后，敲命令git tag就可以打一个新标签：$ git tag v1.0 可以用命令git tag查看所有标签：$ git tag v1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？方法是找到历史提交的commit id，然后打上就可以了：$ git log --pretty=oneline --abbrev-commit 12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101 4c805e2 fix bug 101 e1e9c68 merge with no-ff f52c633 add merge cf810e4 conflict fixed 5dc6824 &amp; simple 14096d0 AND simple b17d20e branch test d46f35e remove test.txt b84166e add test.txt 519219b git tracks changes e43a48b understand how stage works 1094adb append GPL e475afc add distributed eaadf4e wrote a readme file 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：$ git tag v0.9 f52c633 再用命令git tag查看标签：$ git tag v0.9 v1.0 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show查看标签信息：$ git show v0.9 commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9) Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Fri May 18 21:56:54 2018 +0800 add merge diff --git a/readme.txt b/readme.txt ... 可以看到，v0.9确实打在add merge这次提交上。还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb 用命令git show可以看到说明文字：$ git show v0.1 tag v0.1 Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Fri May 18 22:48:43 2018 +0800 version 0.1 released commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1) Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Fri May 18 21:06:15 2018 +0800 append GPL diff --git a/readme.txt b/readme.txt ... 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。操作标签如果标签打错了，也可以删除：$ git tag -d v0.1 Deleted tag &apos;v0.1&apos; (was f15b0dd) 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。如果要推送某个标签到远程，使用命令git push origin：$ git push origin v1.0 Total 0 (delta 0), reused 0 (delta 0) To github.com:michaelliao/learngit.git * [new tag] v1.0 -&gt; v1.0 或者，一次性推送全部尚未推送到远程的本地标签：$ git push origin --tags Total 0 (delta 0), reused 0 (delta 0) To github.com:michaelliao/learngit.git * [new tag] v0.9 -&gt; v0.9 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：$ git tag -d v0.9 Deleted tag &apos;v0.9&apos; (was f52c633) 然后，从远程删除。删除命令也是push，但是格式如下：$ git push origin :refs/tags/v0.9 To github.com:michaelliao/learngit.git - [deleted] v0.9 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。自定义Git在安装Git一节中，我们已经配置了user.name和user.email，实际上，Git还有很多可配置项。比如，让Git显示颜色，会让命令输出看起来更醒目：$ git config --global color.ui true 这样，Git会适当地显示不同的颜色，比如git status命令：文件名就会标上颜色。我们在后面还会介绍如何更好地配置Git，以便让你的工作更高效。忽略特殊文件有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示Untracked files …，有强迫症的童鞋心里肯定不爽。好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore忽略文件的原则是：忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 举个例子：假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件：# Windows: Thumbs.db ehthumbs.db Desktop.ini 然后，继续忽略Python编译产生的.pyc、.pyo、dist等文件或目录：# Python: *.py[cod] *.so *.egg *.egg-info dist build 加上你自己定义的文件，最终得到一个完整的.gitignore文件，内容如下：# Windows: Thumbs.db ehthumbs.db Desktop.ini # Python: *.py[cod] *.so *.egg *.egg-info dist build # My configurations: db.ini deploy_key_rsa 最后一步就是把.gitignore也提交到Git，就完成了！当然检验.gitignore的标准是git status命令是不是说working directory clean。使用Windows的童鞋注意了，如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了：$ git add App.class The following paths are ignored by one of your .gitignore files: App.class Use -f if you really want to add them. 如果你确实想添加该文件，可以用-f强制添加到Git：$ git add -f App.class 或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：$ git check-ignore -v App.class .gitignore:3:*.class App.class Git会告诉我们，.gitignore的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。配置别名有没有经常敲错命令？比如git status？status这个单词真心不好记。如果敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。我们只需要敲一行命令，告诉Git，以后st就表示status：$ git config --global alias.st status 好了，现在敲git st看看效果。当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch：$ git config --global alias.co checkout $ git config --global alias.ci commit $ git config --global alias.br branch 以后提交就可以简写成：$ git ci -m &quot;bala bala bala...&quot; –global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。在撤销修改一节中，我们知道，命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：$ git config --global alias.unstage &apos;reset HEAD&apos; 当你敲入命令：$ git unstage test.py 实际上Git执行的是：$ git reset HEAD test.py 配置一个git last，让其显示最后一次提交信息：$ git config --global alias.last &apos;log -1&apos; 这样，用git last就能显示最近一次的提交：$ git last commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2 Merge: bd6ae48 291bea8 Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Thu Aug 22 22:49:22 2013 +0800 merge &amp; fix hello.py 甚至还有人丧心病狂地把lg配置成了：git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot; 来看看git lg的效果：为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！配置文件配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中：$ cat .git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true [remote &quot;origin&quot;] url = git@github.com:michaelliao/learngit.git fetch = +refs/heads/*:refs/remotes/origin/* [branch &quot;master&quot;] remote = origin merge = refs/heads/master [alias] last = log -1 别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中：$ cat .gitconfig [alias] co = checkout ci = commit br = branch st = status [user] name = Your Name email = your@email.com 配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。搭建Git服务器在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。假设你已经有sudo权限的用户账号，下面，正式开始安装。第一步，安装git：$ sudo apt-get install git 第二步，创建一个git用户，用来运行git服务：$ sudo adduser git 第三步，创建证书登录：收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。第四步，初始化Git仓库：先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：$ sudo git init --bare sample.git Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：$ sudo chown -R git:git sample.git 第五步，禁用shell登录：出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：git:x:1001:1001:,,,:/home/git:/bin/bash 改为：git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。第六步，克隆远程仓库：现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：$ git clone git@server:/srv/sample.git Cloning into &apos;sample&apos;... warning: You appear to have cloned an empty repository. 剩下的推送就简单了。管理公钥如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。管理权限有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。这里我们也不介绍Gitolite了，不要把有限的生命浪费到权限斗争中。本文转载自廖旭峰官网Git教程]]></content>
      <categories>
        <category>软件·服务器</category>
        <category>Git教程</category>
      </categories>
      <tags>
        <tag>Git教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git教程(三)]]></title>
    <url>%2FGit-tutorial-3.html</url>
    <content type="text"><![CDATA[远程仓库到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：点“Add Key”，你就应该看到已经添加的Key：为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。添加远程库在GitHub上的创建一个新的仓库learngit，创建好后GitHub告诉我们这个learngit仓库还是空的，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：$ git remote add origin git@github.com:michaelliao/learngit.git 请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。下一步，就可以把本地库的所有内容推送到远程库上：$ git push -u origin master Counting objects: 20, done. Delta compression using up to 4 threads. Compressing objects: 100% (15/15), done. Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done. Total 20 (delta 5), reused 0 (delta 0) remote: Resolving deltas: 100% (5/5), done. To github.com:michaelliao/learngit.git * [new branch] master -&gt; master Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;. 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：从现在起，只要本地作了提交，就可以通过命令：$ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！SSH警告当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established. RSA key fingerprint is xx.xx.xx.xx.xx. Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。从远程库克隆上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。首先，登陆GitHub，创建一个新的仓库，名字叫gitskills：我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库：$ git clone git@github.com:michaelliao/gitskills.git Cloning into &apos;gitskills&apos;... remote: Counting objects: 3, done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3 Receiving objects: 100% (3/3), done. 注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了：$ cd gitskills $ ls README.md 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。分支管理分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。创建与合并分支首先，我们创建dev分支，然后切换到dev分支：$ git checkout -b dev Switched to a new branch &apos;dev&apos; git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：$ git branch dev $ git checkout dev Switched to branch &apos;dev&apos; 然后，用git branch命令查看当前分支：$ git branch * dev master git branch命令会列出所有分支，当前分支前面会标一个*号。然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：Creating a new branch is quick. 然后提交：$ git add readme.txt $ git commit -m &quot;branch test&quot; [dev b17d20e] branch test 1 file changed, 1 insertion(+) 现在，dev分支的工作完成，我们就可以切换回master分支：$ git checkout master Switched to branch &apos;master&apos; 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：现在，我们把dev分支的工作成果合并到master分支上：$ git merge dev Updating d46f35e..b17d20e Fast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。合并完成后，就可以放心地删除dev分支了：$ git branch -d dev Deleted branch dev (was b17d20e). 删除后，查看branch，就只剩下master分支了：$ git branch * master 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。解决冲突人生不如意之事十之八九，合并分支往往也不是一帆风顺的。准备新的feature1分支，继续我们的新分支开发：$ git checkout -b feature1 Switched to a new branch &apos;feature1&apos; 修改readme.txt最后一行，改为：Creating a new branch is quick AND simple. 在feature1分支上提交：$ git add readme.txt $ git commit -m &quot;AND simple&quot; [feature1 14096d0] AND simple 1 file changed, 1 insertion(+), 1 deletion(-) 切换到master分支：$ git checkout master Switched to branch &apos;master&apos; Your branch is ahead of &apos;origin/master&apos; by 1 commit. (use &quot;git push&quot; to publish your local commits) Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。在master分支上把readme.txt文件的最后一行改为：Creating a new branch is quick &amp; simple. 提交：$ git add readme.txt $ git commit -m “&amp; simple”[master 5dc6824] &amp; simple1 file changed, 1 insertion(+), 1 deletion(-)现在，master分支和feature1分支各自都分别有新的提交，变成了这样：这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：$ git merge feature1 Auto-merging readme.txt CONFLICT (content): Merge conflict in readme.txt Automatic merge failed; fix conflicts and then commit the result. 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件：$ git status On branch master Your branch is ahead of &apos;origin/master&apos; by 2 commits. (use &quot;git push&quot; to publish your local commits) You have unmerged paths. (fix conflicts and run &quot;git commit&quot;) (use &quot;git merge --abort&quot; to abort the merge) Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: readme.txt no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 我们可以直接查看readme.txt的内容：Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD Creating a new branch is quick &amp; simple. ======= Creating a new branch is quick AND simple. &gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：Creating a new branch is quick and simple. 再提交：$ git add readme.txt $ git commit -m &quot;conflict fixed&quot; [master cf810e4] conflict fixed 现在，master分支和feature1分支变成了下图所示：用带参数的git log也可以看到分支的合并情况：$ git log --graph --pretty=oneline --abbrev-commit * cf810e4 (HEAD -&gt; master) conflict fixed |\ | * 14096d0 (feature1) AND simple * | 5dc6824 &amp; simple |/ * b17d20e branch test * d46f35e (origin/master) remove test.txt * b84166e add test.txt * 519219b git tracks changes * e43a48b understand how stage works * 1094adb append GPL * e475afc add distributed * eaadf4e wrote a readme file 最后，删除feature1分支：$ git branch -d feature1 Deleted branch feature1 (was 14096d0). 工作完成。本文转载自廖旭峰官网Git教程]]></content>
      <categories>
        <category>软件·服务器</category>
        <category>Git教程</category>
      </categories>
      <tags>
        <tag>Git教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git教程(二)]]></title>
    <url>%2FGit-tutorial-2.html</url>
    <content type="text"><![CDATA[版本回退现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：Git is a distributed version control system. Git is free software distributed under the GPL. 然后尝试提交：$ git add readme.txt $ git commit -m &quot;append GPL&quot; [master 1094adb] append GPL 1 file changed, 1 insertion(+), 1 deletion(-) 像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：版本1：wrote a readme fileGit is a version control system. Git is free software. 版本2：add distributedGit is a distributed version control system. Git is free software. 版本3：append GPLGit is a distributed version control system. Git is free software distributed under the GPL. 当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：$ git log commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Fri May 18 21:06:15 2018 +0800 append GPL commit e475afc93c209a690c39c13a46716e8fa000c366 Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Fri May 18 21:03:36 2018 +0800 add distributed commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数：$ git log --pretty=oneline 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL e475afc93c209a690c39c13a46716e8fa000c366 add distributed eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file 需要友情提示的是，你看到的一大串类似1094adb…的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是add distributed的那个版本，怎么做呢？首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：$ git reset --hard HEAD^ HEAD is now at e475afc add distributed –hard参数有啥意义？这个后面再讲，现在你先放心使用。看看readme.txt的内容是不是版本add distributed：$ cat readme.txt Git is a distributed version control system. Git is free software. 果然被还原了。还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态：$ git log commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master) Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Fri May 18 21:03:36 2018 +0800 add distributed commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file 最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb…，于是就可以指定回到未来的某个版本：$ git reset --hard 1094a HEAD is now at 83b0afe append GPL 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。再小心翼翼地看看readme.txt的内容：$ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. 果然，我胡汉三又回来了。Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL：改为指向add distributed：然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？在Git中，总是有后悔药可以吃的。当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：$ git reflog e475afc HEAD@{1}: reset: moving to HEAD^ 1094adb (HEAD -&gt; master) HEAD@{2}: commit: append GPL e475afc HEAD@{3}: commit: add distributed eaadf4e HEAD@{4}: commit (initial): wrote a readme file 终于舒了口气，从输出可知，append GPL的commit id是1094adb，现在，你又可以乘坐时光机回到未来了。管理修改你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：$ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes. 然后，添加：$ git add readme.txt $ git status # On branch master # Changes to be committed: # (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) # # modified: readme.txt # 然后，再修改readme.txt：$ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. 提交：$ git commit -m &quot;git tracks changes&quot; [master 519219b] git tracks changes 1 file changed, 1 insertion(+) 提交后，再看看状态：$ git status On branch master Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txt no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 咦，怎么第二次的修改没有被提交？别激动，我们回顾一下操作过程：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。提交后，用git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别：$ git diff HEAD -- readme.txt diff --git a/readme.txt b/readme.txt index 76d770f..a9c5755 100644 --- a/readme.txt +++ b/readme.txt @@ -1,4 +1,4 @@ Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. -Git tracks changes. +Git tracks changes of files. 可见，第二次修改确实没有被提交。那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit好，现在，把第二次修改提交了，然后开始小结。撤销修改自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行：$ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. My stupid boss still prefers SVN. 在你准备提交前，一杯咖啡起了作用，你猛然发现了stupid boss可能会让你丢掉这个月的奖金！既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下：$ git status On branch master Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txt no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 你可以发现，Git会告诉你，git checkout – file可以丢弃工作区的修改：$ git checkout -- readme.txt 命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。现在，看看readme.txt的文件内容：$ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. 文件内容果然复原了。git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了：$ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. My stupid boss still prefers SVN. $ git add readme.txt 庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交：$ git status On branch master Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: readme.txt Git同样告诉我们，用命令git reset HEAD可以把暂存区的修改撤销掉（unstage），重新放回工作区：$ git reset HEAD readme.txt Unstaged changes after reset: M readme.txt git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。再用git status查看一下，现在暂存区是干净的，工作区有修改：$ git status On branch master Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txt 还记得如何丢弃工作区的修改吗？$ git checkout -- readme.txt $ git status On branch master nothing to commit, working tree clean 整个世界终于清静了！现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把stupid boss提交推送到远程版本库，你就真的惨了……删除文件在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：$ git add test.txt $ git commit -m &quot;add test.txt&quot; [master b84166e] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：$ rm test.txt 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：$ git status On branch master Changes not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: test.txt no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：$ git rm test.txt rm &apos;test.txt&apos; $ git commit -m &quot;remove test.txt&quot; [master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 现在，文件就从版本库中被删除了。小提示：先手动删除文件，然后使用git rm和git add效果是一样的。另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：$ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。本文转载自廖旭峰官网Git教程]]></content>
      <categories>
        <category>软件·服务器</category>
        <category>Git教程</category>
      </categories>
      <tags>
        <tag>Git教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git教程(一)]]></title>
    <url>%2FGit-tutorial-1.html</url>
    <content type="text"><![CDATA[安装Git最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字：在Linux上安装Git首先，你可以试着输入git，看看系统有没有安装Git：$ git The program &apos;git&apos; is currently not installed. You can install it by typing: sudo apt-get install git 像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。老一点的Debian或Ubuntu Linux，要把命令改为sudo apt-get install git-core，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。在Mac OS X上安装Git如果你正在使用Mac做开发，有两种安装Git的方法。一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！在Windows上安装Git在Windows上使用Git，可以从Git官网直接下载安装程序，（网速慢的同学请移步国内镜像），然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！安装完成后配置安装完成后，还需要最后一步设置，在命令行输入：$ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。创建版本库什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：$ mkdir learngit $ cd learngit $ pwd /Users/michael/learngit pwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。第二步，通过git init命令把这个目录变成Git可以管理的仓库：$ git init Initialized empty Git repository in /Users/michael/learngit/.git/ 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。把文件添加到版本库首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。使用Windows的童鞋要特别注意：千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：言归正传，现在我们编写一个readme.txt文件，内容如下：Git is a version control system. Git is free software. 一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。第一步，用命令git add告诉Git，把文件添加到仓库：$ git add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。第二步，用命令git commit告诉Git，把文件提交到仓库：$ git commit -m &quot;wrote a readme file&quot; [master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。嫌麻烦不想输入-m “xxx”行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：$ git add file1.txt $ git add file2.txt file3.txt $ git commit -m &quot;add 3 files.&quot; 本文转载自廖旭峰官网Git教程]]></content>
      <categories>
        <category>软件·服务器</category>
        <category>Git教程</category>
      </categories>
      <tags>
        <tag>Git教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim编辑器]]></title>
    <url>%2FVim-editor.html</url>
    <content type="text"><![CDATA[vim主要模式介绍，vim命令模式。确保系统已经安装了VIM工具[root@panda ~]# rpm -qf `which vim` [root@panda ~]# rpm -qf `which vi` 扩展：问：vi和vim是同一个软件包安装的吗?答：NO，vim是vi的增加版，最明显的区别就是vim可以语法加亮，它完全兼容vi1. vim编辑器模式首次进入文件 —- 命令模式出现 “Insert” —- 编辑模式输入: —- 命令行模式A：从编辑模式到命令行模式怎样切换?编辑模式-&gt;esc-&gt;命令模式-&gt;: -&gt;命令行模式B：字符操作(怎样进入编辑模式?)进入编辑模式 a i o A I O说明：i 当前字符之前插入 (光标前)I 行首插入 (行首)a 当前字符之后插入 (光标后)A 行尾插入(行尾)o下一行插入 (另起一行)O上一行插入(上一行插入)x 向后删除一个字符 等同于deleteX 向前删除一个字符u 撤销一步 每按一次就撤销一次r 替换2. 在命令模式下做的操作：光标定位hjkl 左下上右0 和 home键表示切换到行首， $和end键表示切换到行尾gg 快速定位到文档的首行 , G定位到未行3gg 或者 3G 快速定位到第3行/string(字符串) —–找到或定位你要找的单词或内容，如果相符内容比较多，我们可以通过N、n来进行向上向下查找，并且vi会对查找到的内容进行高亮显示，取消用 :noh/^d —-^意思表示以什么开头 ，，查找以字母d开头的内容/t$ —–$意思表示以什么结尾，，查找以字母t结尾的内容vim + a.txt 打开文件后，光标会自动位于文件的最后一行如何对文本进行编辑删除、复制、粘贴、撤销y 复制（以字符为单位） :表示对单个字符进行复制，如果要复制整行，用yy（以行为单位）复制N行： Nyy ，比如： 2yy ，表示复制2行dd（删除，以行为单位，删除当前光标所在行）删除N行： Ndd ，比如： 2dd ，表示删除2行p ： P粘贴剪切： ddx 删除光标所在位置的字符D 从光标处删除到行尾u 撤销操作ctrl+r 还原撤销过的操作，将做过的撤销操作再还原回去，也就是说撤销前是什么样，再还原成什么样r 替换，或者说用来修改一个字符总结：vim如何进入其它模式a A o O i I 都是可以进行插入，编辑模式： 进入命令行模式v 进入可视模式ctrl+v 进入可视块模式V 进入可视行模式R 擦除、改写，进入替换模式你进入以上模式后，想要退出 ，按esc扩展：插入模式中的操作ctrl+p可以进行补全操作,所需要的内容必须是在当前打开的文件内存在的，它只针对当前文件3. V模式（列）进入v模式 移动光标选择区域、编程的时候需要进行多行注释：1)、ctrl+v 进入列编辑模式2)、向下或向上移动光标，把需要注释、编辑的行的开头选中起来4)、然后按大写的I5)、再插入注释符或者你需要插入的符号,比如”#”6)、再按Esc,就会全部注释或添加了删除：再按ctrl+v 进入列编辑模式；向下或向上移动光标 ；选中注释部分,然后按d, 就会删除注释符号。4. 命令行模式操作:w 保存 save:w! 强制保存:q 没有进行任何修改，退出 quit:q! 修改了，不保存，强制退出:wq 保存并退出:wq! 强制保存并退出:x 保存退出例: wq! 强制保存并退出[root@xuegod63 ~]# ll /etc/shadow ----------. 1 root root 1179 9月 19 12:57 /etc/shadow [root@xuegod63 ~]# vim /etc/shadow 调用外部文件或命令假设：我想要写入我的网卡MAC地址,,我要查看一下,当前在vim编辑文档，照着写。这样好麻烦。在命令行模式下操作：:!ifconfig 调用系统命令!+命令读取其他文件。（把其他文件中的内容追加到当前文档中）:r /etc/hosts文本替换格式 : 范围（其中%所有内容） s分隔符 旧的内容 分隔符 新的内容 （分隔符可以自定义）默认是每一行的第一个符合要求的词 (/g全部):1,3 s/bin/xuegod 替换第1到3行中出现的第一个bin进行替换为xuegod :1,3 s/bin/xuegod/g 替换第1到3行中查找到所有的bin进行替换为xuegod :3 s/xue/aaaaa #只把第3行中内容替换了 :% s/do/xuegod/g 将文本中所有的do替换成xuegod :% s/do/xuegod/gi 将文本中所有的do替换成xuegod, 并且忽略do的大小写 :% s@a@b@g 将文本中所有的a替换成b 5. 自定义vim使用环境临时设置:set nu 设置行号:set nonu 取消设置行号:noh 取消高亮显示永久设置环境vim /etc/vimrc 设置后会影响到系统所有的用户~/.vimrc #在用户的家目录下，创建一个.vimrc。这样只影响到某一个用户，没有自己建一个例：[root@xuegod63 ~]# cat /root/.vimrc set nu [root@xuegod63 ~]# vim /root/.vimrc 6. vim 其他常用命令vim打开多个文件方法1：以上下形势，打开两个文档[root@xuegod63 ~]# vim -o /etc/passwd /etc/hosts 方法2：以左右方式打开两个文档[root@xuegod63 ~]# vim -O /etc/passwd /etc/hosts 注：ctrl+ww 在两文档之间进行切换编辑。大写O左右分屏，小写的o上下分屏比较两个文件内容[root@xuegod63 ~]# cp /etc/passwd mima.txt [root@xuegod63 ~]# echo aaa &gt;&gt; mima.txt [root@xuegod63 ~]# diff /etc/passwd mima.txt 40a41 &gt; aaa [root@xuegod63 ~]# vimdiff /etc/passwd mima.txt 7. 实战1：在windows中编辑好的汉字文本文档，上传到Linux下打开乱码。实验环境：centos7.4 现在系统默认使用的语言是汉语。（系统中必须安装好中文包）。将同目录下“a此文件在windows下打开正常-到linux下vim打开是乱码.txt”上传到Linux服务器上。使用ssh远程连接到Linux上，使用vim打开显示乱码。原因：编码的问题通过iconv命令转码 没有使用过：1参数：-f, –from-code=名称 原始文本编码-t, –to-code=输出编码-o, –output=FILE 输出文件名[root@xuegod63 ~]# mkdir test #创建一个测试目录 [root@xuegod63 ~]# cd test/ 将测试的文件上传到Linux服务器上：[root@xuegod63 ~]# iconv -f gb2312 -t utf8 a此文件在windows下打开正常-到linux下vim打开是乱码.txt -o aa.txt [root@xuegod63 ~]# cat aa.txt #!/bin/bash echo &quot;学神IT&quot; 信息： -l, --list 列举所有已知的字符集 8. 实战2：解决将公司Linux服务器上脚本导到windows上打开串行的问题原因：因为windows和linux处理回车方法不同。上传” b在Linux编辑的文档到windows下没有换行.sh” 到Linux上，打开后正常显示[root@localhost test]# sz b在Linux编辑的文档到windows下没有换行.sh #发送到本地 在window 上打开显示：解决方法：[root@xuegod63 ~]# rpm -ivh /mnt/Packages/dos2unix-6.0.3-7.el7.x86_64.rpm 注： 在centos7上，unix2dos这个命令已经被集成到dos2unix-6.0.3-7.el7.x86_64.rpm包中。在centos6下需要安装unix2dos.xxx.rpm。 [root@localhost test]# unix2dos b在Linux编辑的文档到windows下没有换行.sh [root@localhost test]# sz b在Linux编辑的文档到windows下没有换行.sh #发送到windows本地 显示正常。 注：dos2unix 这个命令是把windows下的回车转成linux类型。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下的tar压缩解压缩命令详解]]></title>
    <url>%2FTar-compression-decompression-command-detailed.html</url>
    <content type="text"><![CDATA[tar :常用参数-c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。-z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出下面的参数-f是必须的-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。# tar -cf all.tar *.jpg 这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。# tar -rf all.tar *.gif 这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。# tar -uf all.tar logo.gif 这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。# tar -tf all.tar 这条命令是列出all.tar包中所有文件，-t是列出文件的意思# tar -xf all.tar 这条命令是解出all.tar包中所有文件，-t是解开的意思压缩tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg# tar -czf jpg.tar.gz *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz# tar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2# tar -cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z# rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux# zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux解压 tar -xvf file.tar //解压 tar包 tar -xzvf file.tar.gz //解压tar.gz tar -xjvf file.tar.bz2 //解压 tar.bz2 tar -xZvf file.tar.Z //解压tar.Z unrar e file.rar //解压rar unzip file.zip //解压zip 解压总结1、.tar 用 tar -xvf 解压2、.gz 用 gzip -d或者gunzip 解压3、.tar.gz和.tgz 用 tar -xzf 解压4、.bz2 用 bzip2 -d或者用bunzip2 解压5、.tar.bz2用tar -xjf 解压6、.Z 用 uncompress 解压7、.tar.Z 用tar -xZf 解压8、.rar 用 unrar e解压9、.zip 用 unzip 解压tar –help 标准帮助文档[root@zelvan ~]# tar --help Usage: tar [OPTION...] [FILE]... GNU `tar&apos; saves many files together into a single tape or disk archive, and can restore individual files from the archive. Examples: tar -cf archive.tar foo bar # Create archive.tar from files foo and bar. tar -tvf archive.tar # List all files in archive.tar verbosely. tar -xf archive.tar # Extract all files from archive.tar. Main operation mode: -A, --catenate, --concatenate append tar files to an archive -c, --create create a new archive -d, --diff, --compare find differences between archive and file system --delete delete from the archive (not on mag tapes!) -r, --append append files to the end of an archive -t, --list list the contents of an archive --test-label test the archive volume label and exit -u, --update only append files newer than copy in archive -x, --extract, --get extract files from an archive Operation modifiers: --check-device check device numbers when creating incremental archives (default) -g, --listed-incremental=FILE handle new GNU-format incremental backup -G, --incremental handle old GNU-format incremental backup --ignore-failed-read do not exit with nonzero on unreadable files --level=NUMBER dump level for created listed-incremental archive -n, --seek archive is seekable --no-check-device do not check device numbers when creating incremental archives --no-seek archive is not seekable --occurrence[=NUMBER] process only the NUMBERth occurrence of each file in the archive; this option is valid only in conjunction with one of the subcommands --delete, --diff, --extract or --list and when a list of files is given either on the command line or via the -T option; NUMBER defaults to 1 --sparse-version=MAJOR[.MINOR] set version of the sparse format to use (implies --sparse) -S, --sparse handle sparse files efficiently Overwrite control: -k, --keep-old-files don&apos;t replace existing files when extracting, treat them as errors --keep-directory-symlink preserve existing symlinks to directories when extracting --keep-newer-files don&apos;t replace existing files that are newer than their archive copies --no-overwrite-dir preserve metadata of existing directories --overwrite overwrite existing files when extracting --overwrite-dir overwrite metadata of existing directories when extracting (default) --recursive-unlink empty hierarchies prior to extracting directory --remove-files remove files after adding them to the archive --skip-old-files don&apos;t replace existing files when extracting, silently skip over them -U, --unlink-first remove each file prior to extracting over it -W, --verify attempt to verify the archive after writing it Select output stream: --ignore-command-error ignore exit codes of children --no-ignore-command-error treat non-zero exit codes of children as error -O, --to-stdout extract files to standard output --to-command=COMMAND pipe extracted files to another program Handling of file attributes: --atime-preserve[=METHOD] preserve access times on dumped files, either by restoring the times after reading (METHOD=&apos;replace&apos;; default) or by not setting the times in the first place (METHOD=&apos;system&apos;) --delay-directory-restore delay setting modification times and permissions of extracted directories until the end of extraction --group=NAME force NAME as group for added files --mode=CHANGES force (symbolic) mode CHANGES for added files --mtime=DATE-OR-FILE set mtime for added files from DATE-OR-FILE -m, --touch don&apos;t extract file modified time --no-delay-directory-restore cancel the effect of --delay-directory-restore option --no-same-owner extract files as yourself (default for ordinary users) --no-same-permissions apply the user&apos;s umask when extracting permissions from the archive (default for ordinary users) --numeric-owner always use numbers for user/group names --owner=NAME force NAME as owner for added files -p, --preserve-permissions, --same-permissions extract information about file permissions (default for superuser) --preserve same as both -p and -s --same-owner try extracting files with the same ownership as exists in the archive (default for superuser) -s, --preserve-order, --same-order member arguments are listed in the same order as the files in the archive Handling of extended file attributes: --acls Enable the POSIX ACLs support --no-acls Disable the POSIX ACLs support --no-selinux Disable the SELinux context support --no-xattrs Disable extended attributes support --selinux Enable the SELinux context support --xattrs Enable extended attributes support --xattrs-exclude=MASK specify the exclude pattern for xattr keys --xattrs-include=MASK specify the include pattern for xattr keys Device selection and switching: -f, --file=ARCHIVE use archive file or device ARCHIVE --force-local archive file is local even if it has a colon -F, --info-script=NAME, --new-volume-script=NAME run script at end of each tape (implies -M) -L, --tape-length=NUMBER change tape after writing NUMBER x 1024 bytes -M, --multi-volume create/list/extract multi-volume archive --rmt-command=COMMAND use given rmt COMMAND instead of rmt --rsh-command=COMMAND use remote COMMAND instead of rsh --volno-file=FILE use/update the volume number in FILE Device blocking: -b, --blocking-factor=BLOCKS BLOCKS x 512 bytes per record -B, --read-full-records reblock as we read (for 4.2BSD pipes) -i, --ignore-zeros ignore zeroed blocks in archive (means EOF) --record-size=NUMBER NUMBER of bytes per record, multiple of 512 Archive format selection: -H, --format=FORMAT create archive of the given format FORMAT is one of the following: gnu GNU tar 1.13.x format oldgnu GNU format as per tar &lt;= 1.12 pax POSIX 1003.1-2001 (pax) format posix same as pax ustar POSIX 1003.1-1988 (ustar) format v7 old V7 tar format --old-archive, --portability same as --format=v7 --pax-option=keyword[[:]=value][,keyword[[:]=value]]... control pax keywords --posix same as --format=posix -V, --label=TEXT create archive with volume name TEXT; at list/extract time, use TEXT as a globbing pattern for volume name Compression options: -a, --auto-compress use archive suffix to determine the compression program -I, --use-compress-program=PROG filter through PROG (must accept -d) -j, --bzip2 filter the archive through bzip2 -J, --xz filter the archive through xz --lzip filter the archive through lzip --lzma filter the archive through lzma --lzop --no-auto-compress do not use archive suffix to determine the compression program -z, --gzip, --gunzip, --ungzip filter the archive through gzip -Z, --compress, --uncompress filter the archive through compress Local file selection: --add-file=FILE add given FILE to the archive (useful if its name starts with a dash) --backup[=CONTROL] backup before removal, choose version CONTROL -C, --directory=DIR change to directory DIR --exclude=PATTERN exclude files, given as a PATTERN --exclude-backups exclude backup and lock files --exclude-caches exclude contents of directories containing CACHEDIR.TAG, except for the tag file itself --exclude-caches-all exclude directories containing CACHEDIR.TAG --exclude-caches-under exclude everything under directories containing CACHEDIR.TAG --exclude-tag=FILE exclude contents of directories containing FILE, except for FILE itself --exclude-tag-all=FILE exclude directories containing FILE --exclude-tag-under=FILE exclude everything under directories containing FILE --exclude-vcs exclude version control system directories -h, --dereference follow symlinks; archive and dump the files they point to --hard-dereference follow hard links; archive and dump the files they refer to -K, --starting-file=MEMBER-NAME begin at member MEMBER-NAME when reading the archive --newer-mtime=DATE compare date and time when data changed only --no-null disable the effect of the previous --null option --no-recursion avoid descending automatically in directories --no-unquote do not unquote filenames read with -T --null -T reads null-terminated names, disable -C -N, --newer=DATE-OR-FILE, --after-date=DATE-OR-FILE only store files newer than DATE-OR-FILE --one-file-system stay in local file system when creating archive -P, --absolute-names don&apos;t strip leading `/&apos;s from file names --recursion recurse into directories (default) --suffix=STRING backup before removal, override usual suffix (&apos;~&apos; unless overridden by environment variable SIMPLE_BACKUP_SUFFIX) -T, --files-from=FILE get names to extract or create from FILE --unquote unquote filenames read with -T (default) -X, --exclude-from=FILE exclude patterns listed in FILE File name transformations: --strip-components=NUMBER strip NUMBER leading components from file names on extraction --transform=EXPRESSION, --xform=EXPRESSION use sed replace EXPRESSION to transform file names File name matching options (affect both exclude and include patterns): --anchored patterns match file name start --ignore-case ignore case --no-anchored patterns match after any `/&apos; (default for exclusion) --no-ignore-case case sensitive matching (default) --no-wildcards verbatim string matching --no-wildcards-match-slash wildcards do not match `/&apos; --wildcards use wildcards (default) --wildcards-match-slash wildcards match `/&apos; (default for exclusion) Informative output: --checkpoint[=NUMBER] display progress messages every NUMBERth record (default 10) --checkpoint-action=ACTION execute ACTION on each checkpoint --full-time print file time to its full resolution --index-file=FILE send verbose output to FILE -l, --check-links print a message if not all links are dumped --no-quote-chars=STRING disable quoting for characters from STRING --quote-chars=STRING additionally quote characters from STRING --quoting-style=STYLE set name quoting style; see below for valid STYLE values -R, --block-number show block number within archive with each message --show-defaults show tar defaults --show-omitted-dirs when listing or extracting, list each directory that does not match search criteria --show-transformed-names, --show-stored-names show file or archive names after transformation --totals[=SIGNAL] print total bytes after processing the archive; with an argument - print total bytes when this SIGNAL is delivered; Allowed signals are: SIGHUP, SIGQUIT, SIGINT, SIGUSR1 and SIGUSR2; the names without SIG prefix are also accepted --utc print file modification times in UTC -v, --verbose verbosely list files processed --warning=KEYWORD warning control -w, --interactive, --confirmation ask for confirmation for every action Compatibility options: -o when creating, same as --old-archive; when extracting, same as --no-same-owner Other options: -?, --help give this help list --restrict disable use of some potentially harmful options --usage give a short usage message --version print program version Mandatory or optional arguments to long options are also mandatory or optional for any corresponding short options. The backup suffix is `~&apos;, unless set with --suffix or SIMPLE_BACKUP_SUFFIX. The version control may be set with --backup or VERSION_CONTROL, values are: none, off never make backups t, numbered make numbered backups nil, existing numbered if numbered backups exist, simple otherwise never, simple always make simple backups Valid arguments for the --quoting-style option are: literal shell shell-always c c-maybe escape locale clocale *This* tar defaults to: --format=gnu -f- -b20 --quoting-style=escape --rmt-command=/etc/rmt --rsh-command=/usr/bin/ssh Report bugs to &lt;bug-tar@gnu.org&gt;.]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>tar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos 7 下firewalld防火墙配置命令]]></title>
    <url>%2FFirewalld-configuration-command.html</url>
    <content type="text"><![CDATA[centos7版本对防火墙进行加强,不再使用原来的iptables,启用firewalld1.firewalld的基本使用启动： systemctl start firewalld 查状态：systemctl status firewalld 停止： systemctl disable firewalld 禁用： systemctl stop firewalld 在开机时启用一个服务：systemctl enable firewalld.service 在开机时禁用一个服务：systemctl disable firewalld.service 查看服务是否开机启动：systemctl is-enabled firewalld.service 查看已启动的服务列表：systemctl list-unit-files|grep enabled 查看启动失败的服务列表：systemctl --failed 2.配置firewalld-cmd查看版本： firewall-cmd --version 查看帮助： firewall-cmd --help 显示状态： firewall-cmd --state 查看所有打开的端口： firewall-cmd --zone=public --list-ports 更新防火墙规则： firewall-cmd --reload 查看区域信息: firewall-cmd --get-active-zones 查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0 拒绝所有包：firewall-cmd --panic-on 取消拒绝状态： firewall-cmd --panic-off 查看是否拒绝： firewall-cmd --query-panic 3.那怎么开启一个端口呢添加firewall-cmd --zone=public(作用域) --add-port=80/tcp(端口和访问类型) --permanent(永久生效) firewall-cmd --zone=public --add-service=http --permanent firewall-cmd --reload # 重新载入，更新防火墙规则 firewall-cmd --zone= public --query-port=80/tcp #查看 firewall-cmd --zone= public --remove-port=80/tcp --permanent # 删除 firewall-cmd --list-services firewall-cmd --get-services firewall-cmd --add-service=&lt;service&gt; firewall-cmd --delete-service=&lt;service&gt; 在每次修改端口和服务后/etc/firewalld/zones/public.xml文件就会被修改,所以也可以在文件中之间修改,然后重新加载使用命令实际也是在修改文件，需要重新加载才能生效。firewall-cmd --zone=public --query-port=80/tcp firewall-cmd --zone=public --query-port=8080/tcp firewall-cmd --zone=public --query-port=3306/tcp firewall-cmd --zone=public --add-port=8080/tcp --permanent firewall-cmd --zone=public --add-port=3306/tcp --permanent firewall-cmd --zone=public --query-port=3306/tcp firewall-cmd --zone=public --query-port=8080/tcp firewall-cmd --reload # 重新加载后才能生效 firewall-cmd --zone=public --query-port=3306/tcp firewall-cmd --zone=public --query-port=8080/tcp 4.参数解释–add-service #添加的服务 –zone #作用域 –add-port=80/tcp #添加端口，格式为：端口/通讯协议 –permanent #永久生效，没有此参数重启后失效 5.详细使用firewall-cmd --permanent --zone=public --add-rich-rule=&apos;rule family=&quot;ipv4&quot; source address=&quot;192.168.0.4/24&quot; service name=&quot;http&quot; accept&apos; //设置某个ip访问某个服务 firewall-cmd --permanent --zone=public --remove-rich-rule=&apos;rule family=&quot;ipv4&quot; source address=&quot;192.168.0.4/24&quot; service name=&quot;http&quot; accept&apos; //删除配置 firewall-cmd --permanent --add-rich-rule &apos;rule family=ipv4 source address=192.168.0.1/2 port port=80 protocol=tcp accept&apos; //设置某个ip访问某个端口 firewall-cmd --permanent --remove-rich-rule &apos;rule family=ipv4 source address=192.168.0.1/2 port port=80 protocol=tcp accept&apos; //删除配置 firewall-cmd --query-masquerade # 检查是否允许伪装IP firewall-cmd --add-masquerade # 允许防火墙伪装IP firewall-cmd --remove-masquerade # 禁止防火墙伪装IP firewall-cmd --add-forward-port=port=80:proto=tcp:toport=8080 # 将80端口的流量转发至8080 firewall-cmd --add-forward-port=proto=80:proto=tcp:toaddr=192.168.1.0.1 # 将80端口的流量转发至192.168.0.1 firewall-cmd --add-forward-port=proto=80:proto=tcp:toaddr=192.168.0.1:toport=8080 # 将80端口的流量转发至192.168.0.1的8080端口]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Firewalld</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos 7 下修改ssh端口和限制root远程登录]]></title>
    <url>%2FModify-ssh-port-and-limit-root-remote-login.html</url>
    <content type="text"><![CDATA[一、修改ssh端口第一步：修改SSH配置文件 （注意是sshd_config而不是ssh_config，多了个d）vim /etc/ssh/sshd_config 找到“#Port 22”，这一行直接键入“yyp”复制该行到下一行，然后把两行的“#”号即注释去掉，修改成：Port 22 Port 17569 SSH默认监听端口是22，如果你不强制说明别的端口，”Port 22”注不注释都是开放22访问端口。上面我保留了22端口，防止之后因为各种权限和配置问题，导致连22端口都不能访问了，那就尴尬了。等一切都ok了，再关闭22端口。Ok，继续，我增加了17569端口，大家修改端口时候最好挑10000~65535之间的端口号，10000以下容易被系统或一些特殊软件占用，或是以后新应用准备占用该端口的时候，却被你先占用了，导致软件无法运行。第二步：如果你关闭了SELinux，可以忽略第二步。先查看SELinux开放给ssh使用的端口[root@zelvan ~]# semanage port -l|grep ssh 我的系统打印如下：ssh_port_t tcp 22 可知，SELinux没有给SSH开放10086端口，那么我们来添加该端口：[root@zelvan ~]# semanage port -a -t ssh_port_t -p tcp 17569 完成后，再次查看[root@zelvan ~]# semanage port -l|grep ssh ssh_port_t tcp 22，17569 第三步：如果你关闭了防火墙，可以忽略第三步，话说防火墙不开启太危险了，建议开启。先查看防火墙是否开启了17569端口：[root@zelvan ~]# firewall-cmd --permanent --query-port=17569/tcp 打印结果如下： no表示没有开放17569端口，那么添加下该端口：[root@zelvan ~]# firewall-cmd --permanent --add-port=17569/tcp 打印结果如下： success重新加载防火墙策略：[root@zelvan ~]# firewall-cmd --reload 执行成功后，查看17569端口是否被开启：[root@zelvan ~]# firewall-cmd --permanent --query-port=17569/tcp 打印结果如下： Yes第四步：重启SSH服务和防火墙，最好也重启下服务器[root@zelvan ~]# systemctl restart sshd [root@zelvan ~]# systemctl restart firewalld.service [root@zelvan ~]# shutdown -r now 第五步：尝试通过17569端口登录SSH，或者进入该服务器直接本地访问SSH如下：[root@zelvan ~]# ssh root@localhost -p 17569 如果成功，说明17569已经完全可以使用了，接下来你就可以根据上述步骤把sshd_config的Port22注释掉，SELinux和防火墙（Firewalld）关闭22端口就OK，大工造成！二、禁止root远程登录2.1 添加和root权限一样的用户[root@zelvan ~]# adduser admin [root@zelvan ~]# passwd admin （修改密码） 然后输入密码 （密码简单了通不过）系统提示输入确认密码后再输入一次。OK添加成功。2.1.2、修改 /etc/sudoers 文件，找到下面一行，在root下面添加一行，如下所示：[root@zelvan ~]# vim /etc/sudoers ## Allow root to run any commands anywhere root ALL=(ALL) ALL admin ALL=(ALL) ALL 这个文件只读是一种保护机制,如果你使用vi编辑器的话,只要保存时使用:wq!就可以保存了。 或者使用visudo命令来进入sudoers文件的编辑，就可以正常保存2.2禁止root远程登录需要编辑/etc/ssh/sshd_config。 [root@zelvan ~]#vim /etc/ssh/sshd_config 找到 PermitRootLogin 改为 PermitRootLogin no 重启[root@zelvan ~]# systemctl restart sshd附：semanage命令的安装实验环境:CentOS 7 Minimal Installation 64bit(1511) semanage命令是用来查询与修改SELinux默认目录的安全上下文。命令介绍这里推荐最为完整的在线中文版man手册http://man.linuxde.net/semanage CentOS系统自带的chcon工具只能修改文件、目录等的文件类型和策略,无法对端口、消息接口和网络接口等进行管理,semanage能有效胜任SELinux的相关配置工作。[ aliyunzixun@xxx.com ~]# semanage -bash: semanage: command not found [ aliyunzixun@xxx.com ~]# yum install semanage Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile * base: mirror.bit.edu.cn * extras: mirrors.btte.net * updates: mirrors.btte.net No package semanage available. Error: Nothing to do [ aliyunzixun@xxx.com ~]# yum provides semanage Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile * base: mirror.bit.edu.cn * extras: mirrors.btte.net * updates: mirrors.btte.net policycoreutils-python-2.2.5-20.el7.x86_64 : SELinux policy core python utilities Repo : base Matched from: Filename : /usr/sbin/semanage 安装,这里直接使用tab键补全功能可以方便的找到要安装的包。tab补全功能参考http://blog.csdn.net/capricorn90/article/details/52558280[ aliyunzixun@xxx.com ~]# yum -y install policycoreutils-python.x86_64 命令常用格式管理登录linux的用户和SELinux局限的用户之间的映射semanage login [-S store] -{a|d|m|l|n|D} [-sr] login_name | %groupname 管理策略模块semanage module [-S store] -{a|d|l} [-m [–enable | –disable] ] module_name 管理网络端口类型定义semanage port [-S store] -{a|d|m|l|n|D} [-tr] [-p proto] port | port_range]]></content>
      <categories>
        <category>Linux</category>
        <category>Centos</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的Next主题详细配置]]></title>
    <url>%2FHexo's-Next-theme-detailed-configuration.html</url>
    <content type="text"><![CDATA[经过一番不懈的努力，我们终于按照Hexo免费搭建一个属于自己的博客搭建好了一个属于自己的博客，并且还安装了一个Next主题，但是我们的博客一开始还是很简陋的，我们需要把她装修一下。在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件。 以下所有终端执行的命令都在你的Hexo根目录下 1、基本信息配置基本信息包括：博客标题、作者、描述、语言等等。 打开 站点配置文件 ，找到Site模块title: 标题 subtitle: 副标题 description: 描述 author: 作者 language: 语言（简体中文是zh-Hans） timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 关于 站点配置文件 中的其他配置可参考站点配置2、菜单设置菜单包括：首页、归档、分类、标签、关于等等 我们刚开始默认的菜单只有首页和归档两个，不能够满足我们的要求，所以需要添加菜单，打开 主题配置文件 找到Menu Settingsmenu: home: / || home //首页 archives: /archives/ || archive //归档 categories: /categories/ || th //分类 tags: /tags/ || tags //标签 about: /about/ || user //关于 #schedule: /schedule/ || calendar //日程表 #sitemap: /sitemap.xml || sitemap //站点地图 #commonweal: /404/ || heartbeat //公益404 看看你需要哪个菜单就把哪个取消注释打开就行了；关于后面的格式，以archives: /archives/ || archive为例：|| 之前的/archives/表示标题“归档”，关于标题的格式可以去themes/next/languages/zh-Hans.yml中参考或修改||之后的archive表示图标，可以去Font Awesome中查看或修改，Next主题所有的图标都来自Font Awesome。3、Next主题样式设置我们百里挑一选择了Next主题，不过Next主题还有4种风格供我们选择，打开 主题配置文件 找到Scheme Settings# Schemes # scheme: Muse # scheme: Mist # scheme: Pisces scheme: Gemini 4种风格大同小异，本人用的是Gemini风格，你们可以选择自己喜欢的风格。4、侧栏设置侧栏设置包括：侧栏位置、侧栏显示与否、文章间距、返回顶部按钮等等 打开 主题配置文件 找到sidebar字段sidebar: # Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效） position: left //靠左放置 #position: right //靠右放置 # Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效） #display: post //默认行为，在文章页面（拥有目录列表）时显示 display: always //在所有页面中都显示 #display: hide //在所有页面中都隐藏（可以手动展开） #display: remove //完全移除 offset: 12 //文章间距（只对Pisces | Gemini两种风格有效） b2t: false //返回顶部按钮（只对Pisces | Gemini两种风格有效） scrollpercent: true //返回顶部按钮的百分比 5、头像设置打开 主题配置文件 找到Sidebar Avatar字段# Sidebar Avatar avatar: /images/header.jpg 这是头像的路径，只需把你的头像命名为header.jpg（随便命名）放入themes/next/source/images中，将avatar的路径名改成你的头像名就OK啦！6、设置RSS1、先安装 hexo-generator-feed 插件$ npm install hexo-generator-feed --save 2、打开 站点配置文件 找到Extensions在下面添加# RSS订阅 feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: &apos; &apos; 3、打开 主题配置文件 找到rss，设置为rss: /atom.xml 7、添加分类模块1、新建一个分类页面$ hexo new page categories 2、你会发现你的source文件夹下有了categorcies/index.md，打开index.md文件将title设置为title: 分类3、打开 主题配置文件 找到menu，将categorcies取消注释4、把文章归入分类只需在文章的顶部标题下方添加categories字段，即可自动创建分类名并加入对应的分类中举个栗子：title: 分类测试文章标题 categories: 分类名 8、添加标签模块1、新建一个标签页面$ hexo new page tags 2、你会发现你的source文件夹下有了tags/index.md，打开index.md文件将title设置为title: 标签3、打开 主题配置文件 找到menu，将tags取消注释4、把文章添加标签只需在文章的顶部标题下方添加tags字段，即可自动创建标签名并归入对应的标签中举个栗子：title: 标签测试文章标题tags: - 标签1 - 标签2 ... 9、添加关于模块1、新建一个关于页面$ hexo new page about 2、你会发现你的source文件夹下有了about/index.md，打开index.md文件即可编辑关于你的信息，可以随便编辑。3、打开 主题配置文件 找到menu，将about取消注释10、添加搜索功能1、安装 hexo-generator-searchdb 插件$ npm install hexo-generator-searchdb --save 2、打开 站点配置文件 找到Extensions在下面添加#搜索 search: path: search.xml field: post format: html limit: 10000 3、打开 主题配置文件 找到Local search，将enable设置为true11、添加阅读全文按钮因为在你的博客主页会有多篇文章，如果你想让你的文章只显示一部分，多余的可以点击阅读全文来查看，那么你需要在你的文章中添加&lt;!--more--&gt; 其后面的部分就不会显示了，只能点击阅读全文才能看12、修改文章内链接文本样式效果图打开文件 themes/next/source/css/_common/components/post/post.styl，在末尾添加.post-body p a { color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover { color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; } } 其中选择 .post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。13、设置网站缩略图标从网上看了很多设置方法都是说把favicon.ico放到站点目录的source目录下就可以了，可是我试了好多遍，并不行。 我的设置方法是这样的：把你的图片（png或jpg格式，不是favicon.ico）放在themes/next/source/images里，然后打开 主题配置文件 找到favicon，将small、medium、apple_touch_icon三个字段的值都设置成/images/图片名.jpg就可以了，其他字段都注释掉。14、设置文章字体的颜色、大小如果想设置某一句的颜色或大小，只需用html语法写出来就行了&lt;font color=&quot;#FF0000&quot;&gt; 我可以设置这一句的颜色哈哈 &lt;/font&gt; &lt;font size=6&gt; 我还可以设置这一句的大小嘻嘻 &lt;/font&gt; &lt;font size=5 color=&quot;#FF0000&quot;&gt; 我甚至可以设置这一句的颜色和大小呵呵&lt;/font&gt; 接下来就是见证奇迹的时刻我可以设置这一句的颜色哈哈我还可以设置这一句的大小嘻嘻我甚至可以设置这一句的颜色和大小呵呵15、设置文字居中设置方法：&lt;center&gt;这一行需要居中&lt;/center&gt; 注意：简书中此方法无效16、添加评论系统目前国内比较有名的多说、网易云跟帖评论系统都已停止服务了，国外的Disqus评论系统还得需要翻墙，所以不推荐使用，剩下的还有搜狐畅言、友言、来必力等。 本来想使用畅言的，结果注册完之后还得要求备案，我只想说F开头的那个单词，果断放弃。 后来选择了友言 1、进入友言官网注册、登录步骤我就不介绍了2、登录完成之后，点击获取代码，你会发现出来了一段代码，里面有你的uid=12345673、打开 主题配置文件 找到youyan_uid将值设置为上面的uid就可以了17、添加站点访问计数站点访问计数有名的就是不蒜子，使用起来非常方便1、安装脚本打开 themes/next/layout/_partial/footer.swig，将下面这段代码添加到里面&lt;div&gt; &lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot; style=&apos;display:none&apos;&gt; 本站总访问量 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 次 &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot; style=&apos;display:none&apos;&gt; 有&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人看过我的博客啦 &lt;/span&gt; &lt;/div&gt; 添加的位置如下图，可自行根据个人喜好更换位置2、以上只是显示站点的访问次数，如果想显示每篇文章的访问次数，打开 themes/next/layout/_macro/post.swig，在第一行增加is_pv字段{% macro render(post, is_index, is_pv, post_extra_class) %} 然后将这段代码插入到里面{% if is_pv %} | 次阅读 {% endif %} 插入的位置然后再打开 themes/next/layout/post.swig，这个文件是文章的模板，给render方法传入参数（对应刚才添加的is_pv字段）最后再打开 themes/next/layout/index.swig，这个文件是首页的模板，给render方法传入参数（对应刚才添加的is_pv字段）OK！设置完毕。18、去掉文章目录标题的自动编号我们自己写文章的时候一般都会自己带上标题编号，但是默认的主题会给我们带上编号，很是别扭，如何去掉呢？打开主题配置文件，找到将number改为false即可 更多1、还有其他更多的主题配置，请查看主题配置2、还有其他更多的插件，请查看Hexo插件]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小化安装Centos 7.5后配置]]></title>
    <url>%2FConfigure-after-installing-Centos.html</url>
    <content type="text"><![CDATA[1.配置网络1.1 编辑网卡配置文件1vi /etc/sysconfig/network-script/ifcfg-eth341.2 修改下述配置1234567ONBOOT = “yes” #开机自启动 BOOTPROTO = “static” #static/dhcp IPADDR = “192.168.99.100” #IP地址 NETMASK = “255.255.255.0” #子网掩码 GATEWAY = “192.168.99.1” #网关 DNS1 = “202.103.44.150” #DNS1 DNS2 = “202.103.24.68” #DNS21.3 重启网络服务Systemcal restart network.service2.修改主机名2.1查看主机名Hostname 或者 hostnamectl2.2修改主机名hostnamectl set-hostname centos或者 vi /etc/hostsname3.配置yum源1[root@zelvan ~]# vi /etc/yum.repo.d/Centos7.repo4.安装常用软件1[root@zelvan ~]# yum -y install net-tools vim gcc gcc-c++ wget bzip2 unzip5.系统更新1[root@zelvan ~]# yum update]]></content>
      <categories>
        <category>Linux</category>
        <category>Centos</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
</search>
